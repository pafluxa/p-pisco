import healpy
import numpy
import pylab
__author__ = "Pedro Fluxa R."
__email__  = "pedro@fluxanet.net"

'''
This is a module to compute the Complex Mueller Matrix Fields described in O'Dea et al. 2006.
(https://arxiv.org/pdf/astro-ph/0610361.pdf)

E_a is a tuple containing arrays of the complex electric fields of the beams, such that

    E_a = (Ex_co, Ex_cx)
    E_b = (Ey_co, Ey_cx)

where E_x/y corresponds to the electric field measured parallel or perpendicular to the
receiver's optical plane of incidence. `co` and `cx` are the Co and Cross polarized
components of such fields.

These fields are usually generated by GRASP so you should not care too much about them :-)
'''

class ComplexMuellerMatrix( object ):

    def __init__( self ):
        pass

    @classmethod
    def make_optical_mueller_matrix( cls, beam_nside, Ex_co, Ex_cx, Ey_co, Ey_cx , grid_size ):

        self = cls()
        
        self.max_pix = healpy.ang2pix( beam_nside, grid_size, 0.0 )
        
        self.npix    = healpy.nside2npix( beam_nside )

        '''
        self.fields = ( Ex_co,  
                        Ex_cx, 
                        Ey_co, 
                        Ey_cx )
        
        self.M_TT = self.compute_MTT()
        self.M_TQ = self.compute_MTQ()
        self.M_TU = self.compute_MTU()
        self.M_TV = self.compute_MTV()
        '''
        
        self.fields = ( Ex_co[ 0:self.max_pix ],  
                        Ex_cx[ 0:self.max_pix ], 
                        Ey_co[ 0:self.max_pix ], 
                        Ey_cx[ 0:self.max_pix ] )

        zeroes = numpy.zeros( self.npix - self.max_pix, dtype='float' )
        
        self.M_TT = numpy.concatenate( (self.compute_MTT(), zeroes ) )
        self.M_TQ = numpy.concatenate( (self.compute_MTQ(), zeroes ) )
        self.M_TU = numpy.concatenate( (self.compute_MTU(), zeroes ) )
        self.M_TV = numpy.concatenate( (self.compute_MTV(), zeroes ) )
        
        self.M_QT = numpy.concatenate( (self.compute_MQT(), zeroes ) )
        self.M_QQ = numpy.concatenate( (self.compute_MQQ(), zeroes ) )
        self.M_QU = numpy.concatenate( (self.compute_MQU(), zeroes ) )
        self.M_QV = numpy.concatenate( (self.compute_MQV(), zeroes ) )

        self.M_UT = numpy.concatenate( (self.compute_MUT(), zeroes ) )
        self.M_UQ = numpy.concatenate( (self.compute_MUQ(), zeroes ) )
        self.M_UU = numpy.concatenate( (self.compute_MUU(), zeroes ) )
        self.M_UV = numpy.concatenate( (self.compute_MUV(), zeroes ) )

        self.M_VT = numpy.concatenate( (self.compute_MVT(), zeroes ) )
        self.M_VQ = numpy.concatenate( (self.compute_MVQ(), zeroes ) )
        self.M_VU = numpy.concatenate( (self.compute_MVU(), zeroes ) )
        self.M_VV = numpy.concatenate( (self.compute_MVV(), zeroes ) )
        
        self.M_TT   = self.M_TT
        self.M_TP   = self.M_TQ#0.5*( self.M_TQ - 1.j*self.M_TU )
        self.M_TPs  = self.M_TU#0.5*( self.M_TQ + 1.j*self.M_TU )
        self.M_TV   = self.M_TV
        self.M_PT   = self.M_QT# + 1.j*self.M_UT
        self.M_PP   = self.M_QQ#0.5*(self.M_QQ + self.M_UU) + 0.5*1.j*(self.M_UQ - self.M_QU)
        self.M_PPs  = self.M_QU#0.5*(self.M_QQ - self.M_UU) + 0.5*1.j*(self.M_UQ + self.M_QU)
        self.M_PV   = self.M_QV#( self.M_QV + 1.j*self.M_UV )
        self.M_PsT  = self.M_UT#numpy.conj( self.M_PT )
        self.M_PsP  = self.M_UQ#numpy.conj( self.M_PPs )
        self.M_PsPs = self.M_UU#numpy.conj( self.M_PP )
        self.M_PsV  = self.M_UV#numpy.conj( self.M_PV )
        self.M_VT   = self.M_VT
        self.M_VP   = self.M_VQ#0.5*( self.M_VQ - 1.j*self.M_VU )
        self.M_VPs  = self.M_VU#0.5*( self.M_VQ + 1.j*self.M_VU )
        self.M_VV   = self.M_VV
        
        self.M      = self.get_M().reshape( (-1,4,4) )


        return self

    def __as_numpy_array( self ):

        return numpy.asarray( [
                [ self.M_TT ,self.M_TP ,self.M_TPs ,self.M_TV ],
                [ self.M_PT ,self.M_PP ,self.M_PPs ,self.M_PV ],
                [ self.M_PsT,self.M_PsP,self.M_PsPs,self.M_PsV ],
                [ self.M_VT ,self.M_VP ,self.M_VPs ,self.M_VV ] ] ).astype('complex128')

    def get_M( self , complex=True ):

        return self.__as_numpy_array().reshape( (4,4,-1) )

    def plot( self , func ):

        f  = pylab.figure()
        
        healpy.gnomview( func( self.M_TT ), sub=(4,4,1), rot=(0,90) )
        healpy.gnomview( func( self.M_TP ), sub=(4,4,2), rot=(0,90) )
        healpy.gnomview( func(self.M_TPs ), sub=(4,4,3), rot=(0,90) )
        healpy.gnomview( func( self.M_TV ), sub=(4,4,4), rot=(0,90) )
        
        healpy.gnomview( func( self.M_PT ), sub=(4,4,5), rot=(0,90) )
        healpy.gnomview( func( self.M_PP ), sub=(4,4,6), rot=(0,90) )
        healpy.gnomview( func(self.M_PPs ), sub=(4,4,7), rot=(0,90) )
        healpy.gnomview( func( self.M_PV ), sub=(4,4,8), rot=(0,90) )
        
        healpy.gnomview( func( self.M_PsT ), sub=(4,4,9), rot=(0,90) )
        healpy.gnomview( func( self.M_PsP ), sub=(4,4,10), rot=(0,90) )
        healpy.gnomview( func(self.M_PsPs ), sub=(4,4,11), rot=(0,90) )
        healpy.gnomview( func( self.M_PsV ), sub=(4,4,12), rot=(0,90) )
        
        healpy.gnomview( func( self.M_VT ), sub=(4,4,13), rot=(0,90) )
        healpy.gnomview( func( self.M_VP ), sub=(4,4,14), rot=(0,90) )
        healpy.gnomview( func(self.M_VPs ), sub=(4,4,15), rot=(0,90) )
        healpy.gnomview( func( self.M_VV ), sub=(4,4,16), rot=(0,90) )

        pylab.show()
    
    def rotate( self, psi, degrees=False ):
        '''
        Rotates the Complex Mueller Matrix fields by an angle psi
        '''
        if degrees:
            psi *= 3.14159265/180.0

        R = numpy.eye(4).astype( 'complex64' )
        R[1][1] = numpy.exp( -1.j*2*psi )
        R[2][2] = numpy.exp(  1.j*2*psi )

        # Rotate matrices
        for i,m in enumerate(self.M):
            numpy.dot( R, m, out=self.M[i] )


    def compute_MTT( self ):
        '''
        Computes M_TT according to https://arxiv.org/pdf/astro-ph/0610361.pdf.
        See equation 22.1
        '''
        # Extract fields
        Ex_co, Ex_cx, Ey_co, Ey_cx = self.fields

        # Compute stuff
        pwr_a = (Ex_co + Ex_cx )*numpy.conj(Ex_co + Ex_cx)
        pwr_b = (Ey_co + Ey_cx )*numpy.conj(Ey_co + Ey_cx)

        M_TT = 0.5*( pwr_a + pwr_b )

        return M_TT

    def compute_MTQ( self ):
        '''
        Computes M_TQ according to https://arxiv.org/pdf/astro-ph/0610361.pdf.
        See equation 22.1
        '''
        # Extract fields
        Ex_co, Ex_cx, Ey_co, Ey_cx = self.fields

        # Compute stuff
        pwr_x_co =  Ex_co * numpy.conj( Ex_co )
        pwr_x_cx =  Ex_cx * numpy.conj( Ex_cx )

        pwr_y_co =  Ey_co * numpy.conj( Ey_co )
        pwr_y_cx =  Ey_cx * numpy.conj( Ey_cx )

        M_TQ = 0.5*( pwr_x_co - pwr_y_cx + pwr_y_cx - pwr_y_co  )

        return M_TQ


    def compute_MTU( self ):
        '''
        Computes M_TU according to https://arxiv.org/pdf/astro-ph/0610361.pdf.
        See equation 22.1
        '''
        # Extract fields
        Ex_co, Ex_cx, Ey_co, Ey_cx = self.fields
        
        # Compute stuff
        M_TU = 0.5*( Ex_co*numpy.conj(Ex_cx) - Ey_co*numpy.conj(Ey_cx) )
        M_TU += numpy.conj(M_TU)

        return M_TU

    def compute_MTV( self ):
        '''
        '''
        # Extract fields
        Ex_co, Ex_cx, Ey_co, Ey_cx = self.fields

        # Compute stuff
        M_TV = 1/2. * 1.j*( Ex_co*numpy.conj(Ex_cx) + Ey_co*numpy.conj(Ey_cx) )
        M_TV += numpy.conj(M_TV)

        return M_TV

    def compute_MQT( self ):
        '''
        Computes M_TQ according to https://arxiv.org/pdf/astro-ph/0610361.pdf.
        See equation 22.1
        '''
        # Extract fields
        Ex_co, Ex_cx, Ey_co, Ey_cx = self.fields
        # Compute stuff
        pwr_a = (Ex_co + Ex_cx )*numpy.conj(Ex_co + Ex_cx)
        pwr_b = (Ey_co + Ey_cx )*numpy.conj(Ey_co + Ey_cx)

        M_QT = 0.5*( pwr_a - pwr_b )

        return M_QT


    def compute_MQQ( self ):
        '''
        Computes M_TQ according to https://arxiv.org/pdf/astro-ph/0610361.pdf.
        See equation 22.1
        '''
        # Extract fields
        Ex_co, Ex_cx, Ey_co, Ey_cx = self.fields

        # Compute stuff
        pwr_x_co =  Ex_co * numpy.conj( Ex_co )
        pwr_x_cx =  Ex_cx * numpy.conj( Ex_cx )

        pwr_y_co =  Ey_co * numpy.conj( Ey_co )
        pwr_y_cx =  Ey_cx * numpy.conj( Ey_cx )

        M_QQ = 0.5*( pwr_x_co - pwr_x_cx + pwr_y_co - pwr_y_cx )
        
        return M_QQ

    def compute_MQU( self ):
        '''
        Computes M_QU according to https://arxiv.org/pdf/astro-ph/0610361.pdf.
        See equation 22.1
        '''
        # Extract fields
        Ex_co, Ex_cx, Ey_co, Ey_cx = self.fields

        # Compute stuff

        M_QU = 0.5*( Ex_co*numpy.conj(Ex_cx) + Ey_co*numpy.conj(Ey_cx) )
        M_QU += numpy.conj(M_QU)

        return M_QU

    def compute_MQV( self ):
        '''
        Computes M_QV according to https://arxiv.org/pdf/astro-ph/0610361.pdf.
        See equation 22.1
        '''
        # Extract fields
        Ex_co, Ex_cx, Ey_co, Ey_cx = self.fields

        # Compute stuff

        M_QV = 0.5*1j*( Ex_co*numpy.conj(Ex_cx) - Ey_co*numpy.conj(Ey_cx) )
        M_QV += numpy.conj(M_QV)

        return M_QV

    def compute_MUT( self ):
        '''
        Computes M_UT according to https://arxiv.org/pdf/astro-ph/0610361.pdf.
        See equation 22.1
        '''
        # Extract fields
        Ex_co, Ex_cx, Ey_co, Ey_cx = self.fields

        # Compute stuff
        M_UT = 0.5*( -Ex_co*numpy.conj(Ey_cx) + Ex_cx*numpy.conj(Ey_co) )
        M_UT += numpy.conj(M_UT)

        return M_UT

    def compute_MUQ( self ):
        '''
        Computes M_UQ according to https://arxiv.org/pdf/astro-ph/0610361.pdf.
        See equation 22.1
        '''
        # Extract fields
        Ex_co, Ex_cx, Ey_co, Ey_cx = self.fields

        # Compute stuff

        M_UQ = 0.5*( -Ex_co*numpy.conj(Ey_cx) - Ex_cx*numpy.conj(Ey_co) )
        M_UQ += numpy.conj(M_UQ)

        return M_UQ

    def compute_MUU( self ):
        '''
        Computes M_UU according to https://arxiv.org/pdf/astro-ph/0610361.pdf.
        See equation 22.1
        '''
        # Extract fields
        Ex_co, Ex_cx, Ey_co, Ey_cx = self.fields

        # Compute stuff

        M_UU = 0.5*( Ex_co*numpy.conj(Ey_co) - Ex_cx*numpy.conj(Ey_cx) )
        M_UU += numpy.conj(M_UU)

        return M_UU


    def compute_MUV( self ):
        '''
        Computes M_UV according to https://arxiv.org/pdf/astro-ph/0610361.pdf.
        See equation 22.1
        '''
        # Extract fields
        Ex_co, Ex_cx, Ey_co, Ey_cx = self.fields

        # Compute stuff

        M_UV = 0.5j*( Ex_co*numpy.conj(Ey_co) + Ex_cx*numpy.conj(Ey_cx) )
        M_UV += numpy.conj(M_UV)

        return M_UV


    def compute_MVT( self ):
        '''
        Computes M_UV according to https://arxiv.org/pdf/astro-ph/0610361.pdf.
        See equation 22.1
        '''
        # Extract fields
        Ex_co, Ex_cx, Ey_co, Ey_cx = self.fields

        # Compute stuff

        M_VT = 0.5j*( Ex_co*numpy.conj(Ey_cx) - Ex_cx*numpy.conj(Ey_co) )
        M_VT += numpy.conj(M_VT)

        return M_VT

    def compute_MVQ( self ):
        '''
        Computes M_UV according to https://arxiv.org/pdf/astro-ph/0610361.pdf.
        See equation 22.1
        '''
        # Extract fields
        Ex_co, Ex_cx, Ey_co, Ey_cx = self.fields

        # Compute stuff
        M_VQ = 0.5j*( Ex_co*numpy.conj(Ey_cx) + Ex_cx*numpy.conj(Ey_co) )
        M_VQ += numpy.conj(M_VQ)

        return M_VQ

    def compute_MVU( self ):
        '''
        Computes M_UV according to https://arxiv.org/pdf/astro-ph/0610361.pdf.
        See equation 22.1
        '''
        # Extract fields
        Ex_co, Ex_cx, Ey_co, Ey_cx = self.fields

        # Compute stuff

        M_VU = 0.5j*( -Ex_co*numpy.conj(Ey_co) + Ey_cx*numpy.conj(Ex_cx) )
        M_VU += numpy.conj(M_VU)

        return M_VU

    def compute_MVV( self ):
        '''
        Computes M_UV according to https://arxiv.org/pdf/astro-ph/0610361.pdf.
        See equation 22.1
        '''
        # Extract fields
        Ex_co, Ex_cx, Ey_co, Ey_cx = self.fields
        # Compute stuff
        M_VV = 0.5*( Ex_co*numpy.conj(Ey_co) + Ex_cx*numpy.conj(Ey_cx) )
        M_VV += numpy.conj(M_VV)

        return M_VV
